- Feature Name: `mtls-registry-authentication`
- Start Date: 2025-11-18
- RFC PR: [rust-lang/rfcs#0000](https://github.com/rust-lang/rfcs/pull/0000)
- Rust Issue: [rust-lang/rust#0000](https://github.com/rust-lang/rust/issues/0000)

# Summary
[summary]: #summary

This is an RFC aimed at allowing Cargo to present client certificates when forming http connections and support mutual TLS authentication with registries.

# Motivation
[motivation]: #motivation

Some organizations require client identity verification when interacting with privately hosted services. This can be achieved a number of ways, but is commonly done with certificates in a process called "mutual TLS" (mTLS).

Cargo does not currently support forwarding client certificate information when it configures it's `libcurl` http handle. This poses an issue for organizations that host private crate registries and perform client authentication via certificates, since there is no alternative way to forward these client provided certificates.

Authentication at the TLS level is different from the token-based methods for [Registry Authenticaion](https://doc.rust-lang.org/cargo/reference/registry-authentication.html) exposed by the [Credential Provider Protocol](https://doc.rust-lang.org/cargo/reference/credential-provider-protocol.html) since it takes place before the connection to the registry is established. It is not currently possible to write a [credential plugin](https://doc.rust-lang.org/cargo/reference/registry-authentication.html#credential-plugins) that enables this type of authentication with a registry.

For additional context, many private services are reverse-proxied by web servers like Nginx, Apache, HAproxy, etc... to provide additional authentication features like SSO, SCIM and LDAP in addition to client identity verification.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

Users will be able to provide their certificates and key files to Cargo via the [http] section of the $HOME/.cargo/config.toml. When http connections are made, these client certificates will be presented.

```toml
[http]
client-ssl-cert = "/etc/ssl/client-cert.pem"
client-ssl-key = "/etc/ssl/client-key.pem"
```

Users that have passphrase protected key files can specify such, and will be prompted for a passphrase when their key is used.

```toml
[http]
client-ssl-cert = "/etc/ssl/client-cert.pem"
client-ssl-key = "/etc/ssl/client-key.pem"
client-ssl-key-protected = true
```

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

The currently used crate for `libcurl` exposes methods for setting these certificates, keys, and specifying key passwords, and can be used to set these configuration options when http handles are being configured. These methods are:
* `curl::easy::Easy::ssl_cert`
* `curl::easy::Easy::ssl_key`
* `curl::easy::Easy::key_password`

These "easy" methods wrap well tested code in the curl source:
* https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_KEYPASSWD.md
* https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_SSLKEY.md
* https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md
* https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_SSLCERT.md

If the `client-ssl-key-protected` option is set, a key passphrase will be securely prompted from the user.

# Drawbacks
[drawbacks]: #drawbacks

This adds additional complexity to Cargo's HTTP configuration, and the potential for credential mismangagment. Depending on the way that key passphrases are managed, this could have impacts on where in the code http handles are configured.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

- These new options are placed in the `CargoHttpConfig`, since they most closely align with configuration options for http connections.

- In the examle I used the PEM key type since this is the default used by https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md. Certificates in the DER format exist but are less common due to lack of OpenSSL support.

- https://github.com/rust-lang/cargo/issues/10641 first proposed this feature, but chose to specify the `client-ssl-key-password` as a plaintext password directly in the `config.toml`. This is similar to storing unencrypted credentials on disk, so was avoided in favor of a `client-ssl-key-protected` boolean with a runtime prompt.

- It's easy to prompt for the key passphrase when configuring the http handle, but if many handles need to be configured the user will have a bad experience repeatedly typing their password. Handles may need to be reused in this case, or the password could be prompted at an earlier stage and passed through to other parts of the code, but this has additional complexity/scope of modification downsides.

- The main impact of not supporting mTLS for registry authentication is that some organizations will be unable to host and use private crate registries.

# Prior art
[prior-art]: #prior-art

`libcurl` has supported client certificates via `CURLOPT_SSLCERT` and `CURLOPT_SSLKEY` since version 7.1 (released August 2000), and there is a huge variety of software that uses mTLS.

Other popular developer tools support mTLS:
* [Git](https://git-scm.com/docs/git-config.html#_variables) (version control system)
* [Python Poetry](https://python-poetry.org/docs/repositories/#custom-certificate-authority-and-mutual-tls-authentication) (packaging and dependency managment)
* [Python uv](https://docs.astral.sh/uv/reference/environment/#ssl_client_cert) (package and project manager)


# Unresolved questions
[unresolved-questions]: #unresolved-questions

- Should the client key passphrase simply be prompted during http handle configuration, or is there a better way to handle this credential?

# Future possibilities
[future-possibilities]: #future-possibilities

`libcurl` supports "ENG" and "PROV" key types https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md. These allow the caller to load private keys and certificate informationn from a hardware/software crypto engine or provider. It's possible that this feature could be expanded in the future to support these additional key types.
